stages:
  - generate
  - test
  - build
  - deploy

generate-swagger:
  stage: generate
  image: mcr.microsoft.com/dotnet/sdk:9.0
  rules:
    - changes:
        - backend/BS.Api/**/*
  script:
    - dotnet restore backend/BS.Api/BS.Api.csproj
    - dotnet build backend/BS.Api/BS.Api.csproj -c Release
    - dotnet tool install --global Swashbuckle.AspNetCore.Cli
    - export PATH="$PATH:/root/.dotnet/tools"
    - dotnet swagger tofile --output swagger.json ./backend/BS.Api/bin/Release/net9.0/BS.Api.dll v1
  artifacts:
    paths:
      - swagger.json

generate-orval:
  stage: generate
  image: node:18
  dependencies:
    - generate-swagger
  rules:
    - changes:
        - backend/BS.Api/**/*
  script:
    - npm ci
    - npx orval --input swagger.json --output src/api
  artifacts:
    paths:
      - src/api

commit-generated-client:
  stage: generate
  image: alpine:latest
  dependencies:
    - generate-orval
  before_script:
    - apk add --no-cache git
  rules:
    - changes:
        - backend/BS.Api/**/*
  script:
    - git config --global user.email "ci-bot@example.com"
    - git config --global user.name "CI Bot"
    - git fetch origin $CI_COMMIT_REF_NAME
    - git checkout $CI_COMMIT_REF_NAME
    - git pull origin $CI_COMMIT_REF_NAME
    - git add src/api
    - |
      if git diff --cached --quiet; then
        echo "üîç No changes in generated API client ‚Äî skipping commit."
      else
        git commit -m "chore: update API client from Swagger [skip ci]"
        git push "https://gitlab-ci-token:${CI_PUSH_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git" HEAD:$CI_COMMIT_REF_NAME
        echo "‚úÖ Committed updated client"
      fi

#test-backend:
#  stage: test
#  image: mcr.microsoft.com/dotnet/sdk:9.0
#  script:
#    - cd backend/BS.IntegrationTests
#    - dotnet restore
#    - dotnet test --verbosity normal

variables:
  BS_API_IMAGE: "$CI_REGISTRY_IMAGE/bs-api:$CI_COMMIT_SHORT_SHA"

build-backend:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker build -t $BS_API_IMAGE -f backend/BS.Api/Dockerfile backend/
    - docker push $BS_API_IMAGE

staging-deploy-backend:
  stage: deploy
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [ "" ]
  environment:
    name: staging
  script:
  - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–ª–∞—Å—Ç–µ—Ä—É K8S..."
  - echo "$KUBECONFIG_BASE64" | base64 -d > kubeconfig && export KUBECONFIG=$PWD/kubeconfig
  - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º ingress..."
  - envsubst < k8s/staging-ingress.yaml | kubectl apply -n staging -f -
  - echo "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–µ–∫—Ä–µ—Ç—ã..."
  - envsubst < k8s/bs-api-secrets.yaml | kubectl apply -n staging -f -
  - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º Deployment..."
  - envsubst < k8s/backend-deployment.yaml | kubectl apply -n staging -f -
  - kubectl rollout restart deployment bs-api -n staging
  variables:
    ASPNETCORE_ENVIRONMENT: "Staging"
  when: manual
  only:
    - branches

production-deploy-backend:
  stage: deploy
  image:
    name: bitnami/kubectl:latest
    entrypoint: [ "" ]
  environment:
    name: production
  script:
    - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–ª–∞—Å—Ç–µ—Ä—É K8S..."
    - echo "$KUBECONFIG_BASE64" | base64 -d > kubeconfig && export KUBECONFIG=$PWD/kubeconfig
    - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º ingress..."
    - envsubst < k8s/production-ingress.yaml | kubectl apply -n production -f -
    - echo "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–µ–∫—Ä–µ—Ç—ã..."
    - envsubst < k8s/bs-api-secrets.yaml | kubectl apply -n production -f -
    - echo "–ü—Ä–∏–º–µ–Ω—è–µ–º Deployment..."
    - envsubst < k8s/backend-deployment.yaml | kubectl apply -n production -f -
    - kubectl rollout restart deployment bs-api -n production
  variables:
    ASPNETCORE_ENVIRONMENT: "Production"
  when: manual
  only:
    - master
