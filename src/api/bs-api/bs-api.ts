/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * BookSharingApi
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AccessTokenResponse,
  ForgotPasswordRequest,
  HttpValidationProblemDetails,
  InfoRequest,
  InfoResponse,
  LoginRequest,
  MapIdentityApiConfirmEmailParams,
  PostLoginParams,
  RefreshRequest,
  RegisterRequest,
  ResendConfirmationEmailRequest,
  ResetPasswordRequest,
  TwoFactorRequest,
  TwoFactorResponse
} from '.././model'



export const postRegister = (
    registerRequest: RegisterRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `/register`,
      registerRequest,options
    );
  }



export const getPostRegisterMutationOptions = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRegister>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRegister(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof postRegister>>>
    export type PostRegisterMutationBody = RegisterRequest
    export type PostRegisterMutationError = AxiosError<HttpValidationProblemDetails>

    export const usePostRegister = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRegister>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRegister>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getPostRegisterMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const postLogin = (
    loginRequest: LoginRequest,
    params?: PostLoginParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccessTokenResponse>> => {
    
    return axios.default.post(
      `/login`,
      loginRequest,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPostLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postLogin>>, {data: LoginRequest;params?: PostLoginParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postLogin(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postLogin>>>
    export type PostLoginMutationBody = LoginRequest
    export type PostLoginMutationError = AxiosError<unknown>

    export const usePostLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postLogin>>, TError,{data: LoginRequest;params?: PostLoginParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postLogin>>,
        TError,
        {data: LoginRequest;params?: PostLoginParams},
        TContext
      > => {

      const mutationOptions = getPostLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const postRefresh = (
    refreshRequest: RefreshRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccessTokenResponse>> => {
    
    return axios.default.post(
      `/refresh`,
      refreshRequest,options
    );
  }



export const getPostRefreshMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRefresh>>, {data: RefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRefresh(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postRefresh>>>
    export type PostRefreshMutationBody = RefreshRequest
    export type PostRefreshMutationError = AxiosError<unknown>

    export const usePostRefresh = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefresh>>, TError,{data: RefreshRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRefresh>>,
        TError,
        {data: RefreshRequest},
        TContext
      > => {

      const mutationOptions = getPostRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const mapIdentityApiConfirmEmail = (
    params?: MapIdentityApiConfirmEmailParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.get(
      `/confirmEmail`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getMapIdentityApiConfirmEmailQueryKey = (params?: MapIdentityApiConfirmEmailParams,) => {
    return [`/confirmEmail`, ...(params ? [params]: [])] as const;
    }

    
export const getMapIdentityApiConfirmEmailQueryOptions = <TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = AxiosError<unknown>>(params?: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMapIdentityApiConfirmEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>> = ({ signal }) => mapIdentityApiConfirmEmail(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type MapIdentityApiConfirmEmailQueryResult = NonNullable<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>>
export type MapIdentityApiConfirmEmailQueryError = AxiosError<unknown>


export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = AxiosError<unknown>>(
 params: undefined |  MapIdentityApiConfirmEmailParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = AxiosError<unknown>>(
 params?: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = AxiosError<unknown>>(
 params?: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useMapIdentityApiConfirmEmail<TData = Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError = AxiosError<unknown>>(
 params?: MapIdentityApiConfirmEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mapIdentityApiConfirmEmail>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getMapIdentityApiConfirmEmailQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postResendConfirmationEmail = (
    resendConfirmationEmailRequest: ResendConfirmationEmailRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `/resendConfirmationEmail`,
      resendConfirmationEmailRequest,options
    );
  }



export const getPostResendConfirmationEmailMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postResendConfirmationEmail>>, {data: ResendConfirmationEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  postResendConfirmationEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostResendConfirmationEmailMutationResult = NonNullable<Awaited<ReturnType<typeof postResendConfirmationEmail>>>
    export type PostResendConfirmationEmailMutationBody = ResendConfirmationEmailRequest
    export type PostResendConfirmationEmailMutationError = AxiosError<unknown>

    export const usePostResendConfirmationEmail = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResendConfirmationEmail>>, TError,{data: ResendConfirmationEmailRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postResendConfirmationEmail>>,
        TError,
        {data: ResendConfirmationEmailRequest},
        TContext
      > => {

      const mutationOptions = getPostResendConfirmationEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const postForgotPassword = (
    forgotPasswordRequest: ForgotPasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `/forgotPassword`,
      forgotPasswordRequest,options
    );
  }



export const getPostForgotPasswordMutationOptions = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postForgotPassword>>, {data: ForgotPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  postForgotPassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postForgotPassword>>>
    export type PostForgotPasswordMutationBody = ForgotPasswordRequest
    export type PostForgotPasswordMutationError = AxiosError<HttpValidationProblemDetails>

    export const usePostForgotPassword = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postForgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postForgotPassword>>,
        TError,
        {data: ForgotPasswordRequest},
        TContext
      > => {

      const mutationOptions = getPostForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const postResetPassword = (
    resetPasswordRequest: ResetPasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `/resetPassword`,
      resetPasswordRequest,options
    );
  }



export const getPostResetPasswordMutationOptions = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postResetPassword>>, {data: ResetPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  postResetPassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postResetPassword>>>
    export type PostResetPasswordMutationBody = ResetPasswordRequest
    export type PostResetPasswordMutationError = AxiosError<HttpValidationProblemDetails>

    export const usePostResetPassword = <TError = AxiosError<HttpValidationProblemDetails>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postResetPassword>>,
        TError,
        {data: ResetPasswordRequest},
        TContext
      > => {

      const mutationOptions = getPostResetPasswordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const postManage2fa = (
    twoFactorRequest: TwoFactorRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TwoFactorResponse>> => {
    
    return axios.default.post(
      `/manage/2fa`,
      twoFactorRequest,options
    );
  }



export const getPostManage2faMutationOptions = <TError = AxiosError<HttpValidationProblemDetails | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postManage2fa>>, {data: TwoFactorRequest}> = (props) => {
          const {data} = props ?? {};

          return  postManage2fa(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostManage2faMutationResult = NonNullable<Awaited<ReturnType<typeof postManage2fa>>>
    export type PostManage2faMutationBody = TwoFactorRequest
    export type PostManage2faMutationError = AxiosError<HttpValidationProblemDetails | void>

    export const usePostManage2fa = <TError = AxiosError<HttpValidationProblemDetails | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManage2fa>>, TError,{data: TwoFactorRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postManage2fa>>,
        TError,
        {data: TwoFactorRequest},
        TContext
      > => {

      const mutationOptions = getPostManage2faMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const getManageInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InfoResponse>> => {
    
    return axios.default.get(
      `/manage/info`,options
    );
  }


export const getGetManageInfoQueryKey = () => {
    return [`/manage/info`] as const;
    }

    
export const getGetManageInfoQueryOptions = <TData = Awaited<ReturnType<typeof getManageInfo>>, TError = AxiosError<HttpValidationProblemDetails | void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetManageInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getManageInfo>>> = ({ signal }) => getManageInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetManageInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getManageInfo>>>
export type GetManageInfoQueryError = AxiosError<HttpValidationProblemDetails | void>


export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = AxiosError<HttpValidationProblemDetails | void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManageInfo>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = AxiosError<HttpValidationProblemDetails | void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManageInfo>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = AxiosError<HttpValidationProblemDetails | void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetManageInfo<TData = Awaited<ReturnType<typeof getManageInfo>>, TError = AxiosError<HttpValidationProblemDetails | void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getManageInfo>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetManageInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postManageInfo = (
    infoRequest: InfoRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InfoResponse>> => {
    
    return axios.default.post(
      `/manage/info`,
      infoRequest,options
    );
  }



export const getPostManageInfoMutationOptions = <TError = AxiosError<HttpValidationProblemDetails | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postManageInfo>>, {data: InfoRequest}> = (props) => {
          const {data} = props ?? {};

          return  postManageInfo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostManageInfoMutationResult = NonNullable<Awaited<ReturnType<typeof postManageInfo>>>
    export type PostManageInfoMutationBody = InfoRequest
    export type PostManageInfoMutationError = AxiosError<HttpValidationProblemDetails | void>

    export const usePostManageInfo = <TError = AxiosError<HttpValidationProblemDetails | void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postManageInfo>>, TError,{data: InfoRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postManageInfo>>,
        TError,
        {data: InfoRequest},
        TContext
      > => {

      const mutationOptions = getPostManageInfoMutationOptions(options);

      return useMutation(mutationOptions);
    }
    